#!/usr/bin/env node
let fs = require("fs");
let path = require("path");

function show_help() {
  let pkg = require("./package.json");
  console.log(
    `
jsdu ${pkg.version}

usage: jsdu [options] [dir]

arguments:
  options: optional, details see below
  dir:     optional, default is current directory

options:
  -h | --help:        show help messages
  -l | --follow-link: follow symbolic links
  -n | --no-link:     skip symbolic links
  -i | --interval:    interval of report, default is 1000ms

examples:
  jsdu
  jsdu .
  jsdu --follow-link .
  jsdu --no-link .
  jsdu --help
`.trim()
  );
}

let dir = ".";
let link = false;
let interval = 1000;
for (let i = 2; i < process.argv.length; i++) {
  let arg = process.argv[i]
  switch (arg) {
    case "-h":
    case "--help":
      show_help();
      process.exit();
      break;
    case "-l":
    case "--follow-link":
      link = true;
      break;
    case "-n":
    case "--no-link":
      link = false;
      break;
    case "-i":
    case "--interval":
      i++
      arg = process.argv[i]
      interval = parseInt(arg);
      if (isNaN(interval)) {
        die(`Error: invalid interval: ${arg}`)
      }
      break;
    default:
      dir = arg;
  }
};
let fs_stat = link ? fs.statSync : fs.lstatSync;

if (typeof process.stdin.setRawMode === "function") {
  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdin.on("data", (data) => {
    // process.kill(process.pid, "SIGTERM");
    console.log("\naborted");
    process.exit();
  });
}

function die(err) {
  console.error(err);
  process.exit(1);
}

let width = 0
function check_width() {
  let n = process.stdout.columns
  if (width != n) {
    width = n
    console.clear()
  }
}
check_width()

let buffer = ''
let last_buffer = ''

function write(str) {
  buffer += str
}

function writeln(str = '') {
  write(str + '\n')
}

function calc_lines(str) {
  let lines = []
  for (let line of str.split('\n')) {
    for (;;) {
      let extra = line.length - width
      if (extra <= 0) {
        lines.push(line)
        break
      }
      if (extra > 0) {
        lines.push(line.slice(0, width))
        line = line.slice(width)
        continue
      }
    }
  }
  if (lines.length > 0 && lines[lines.length - 1] == '') {
    lines.pop()
  }
  return lines
}

function flush() {
  process.stdout.cursorTo(0, 0)
  let current_lines = calc_lines(buffer)
  let last_lines = calc_lines(last_buffer)
  let output_buffer = ''
  let min_lines = Math.min(current_lines.length, last_lines.length)
  for (let i = 0; i < min_lines; i++) {
    let current_line = current_lines[i]
    let last_line = last_lines[i]
    let output_line = current_line
    let extra = last_line.length - output_line.length
    if (extra > 0) {
      output_line += ' '.repeat(extra)
    }
    output_buffer += output_line
    if (output_line.length < width) {
      output_buffer += '\n'
    }
  }
  for (let i = min_lines; i < current_lines.length; i++) {
    let current_line = current_lines[i]
    output_buffer += current_line
    if (current_line.length < width) {
      output_buffer += '\n'
    }
  }
  for (let i = min_lines; i < last_lines.length; i++) {
    let last_line = last_lines[i]
    output_buffer += ' '.repeat(last_line.length)
    if (last_line.length < width) {
      output_buffer += '\n'
    }
  }
  if (output_buffer.endsWith('\n') && !buffer.endsWith('\n')) {
    output_buffer = output_buffer.slice(0, -1)
  }
  process.stdout.write(output_buffer)
  last_buffer = buffer
  buffer = ''
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

let stack = []

let next_report = 0

let sizeUnits = [
  "",
  "K",
  "M",
  "G",
  "T",
  "P",
  "E",
  "Z",
  "Y",
]

function formatSize(bytes) {
  return sizeUnits.map((unit, i) => {
    if (bytes < 1024 ** (i + 1)) {
      let size = Math.round((bytes / 1024 ** i) * 10) / 10 + ""
      if (!size.includes(".")) {
        size += ".0"
      }
      return size + unit
    }
  }).find(s => s) || "Inf"
}

let StopHintMessage = '[Press any key to exit]'

function do_report() {
  check_width()
  rootFiles.sort((a, b) => a.size - b.size)

  let topN = Math.max(5, Math.min(process.stdout.rows - 5, rootFiles.length))
  let maxW = 0
  let maxFileW = 0
  let files = rootFiles.slice(-topN).map(rootFile => {
    let size = formatSize(rootFile.size)
    let file = rootFile.file
    maxW = Math.max(maxW, size.length)
    maxFileW = Math.max(maxFileW, file.length)
    return {size, file}
  })
  let lineW = Math.max(maxW + maxFileW + 2, StopHintMessage.length)

  writeln('='.repeat(lineW))
  for (let {size, file} of files) {
    let extra = Math.max(0, maxW - size.length) + 1
    let pad = ' '.repeat(extra)
    writeln(`${pad}${size} ${file}`)
  }
  writeln('='.repeat(lineW))

  let pending = stack.length
  if (pending > 0) {
    writeln(`pending: ${pending}`)
    writeln()
    write(StopHintMessage)
  } else {
    writeln('done.')
  }
  flush()
}

function report() {
  let now = Date.now()
  if (now < next_report) {
    return
  }
  next_report = now + interval
  do_report()
}

let rootFiles = fs.readdirSync(dir).map(file => {
  if (dir !== ".") {
    file = path.join(dir, file)
  }
  let rootFile = {
    file,
    size: 0,
  }
  stack.push({rootFile, file})
  return rootFile
})

function checkFile(rootFile, file) {
  let stat = null
  try {
    stat = fs_stat(file)
  } catch (error) {
    if (error.code == 'ENOENT') {
      return
    }
    die(error)
  }
  if (stat.isFile()) {
    rootFile.size += stat.size
    return
  }
  if (stat.isDirectory()) {
    let dir = file
    let filenames = null
    try {
      filenames = fs.readdirSync(dir)
    } catch (error) {
      if (error.code == 'EACCES') {
        return
      }
      die(error)
    }
    for (let filename of filenames) {
      let file = path.join(dir, filename)
      stack.push({rootFile, file})
    }
    return
  }
}

async function loop() {
  report()
  for (;stack.length > 0;) {
    let {rootFile, file} = stack.shift()
    checkFile(rootFile, file)
    report()
    await sleep()
  }
  do_report()
  if (!last_buffer.endsWith('\n')) {
    process.stdout.write('\n')
  }
  process.exit()
}

loop()
